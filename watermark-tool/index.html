<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Single Watermark • Perfect Color • Zero Artifacts</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: system-ui, sans-serif; max-width: 1000px; margin: 2rem auto; padding: 1rem; background:#f8f9fc; text-align:center; }
  h1 { margin-bottom: 0.5em; color: #1a1a1a; }
  .drop-zone {
    border: 4px dashed #555;
    border-radius: 20px;
    padding: 80px 20px;
    background: white;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 1.3em;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }
  .drop-zone:hover, .drop-zone.dragover { border-color: #007bff; background:#f0f8ff; }
  .controls { margin: 30px 0; padding: 25px; background:white; border-radius:16px; box-shadow:0 6px 30px rgba(0,0,0,0.12); }
  .wm-choice {
    display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap;
  }
  .wm-btn {
    padding: 14px 28px; font-size: 1.1em; border: 2px solid #ddd; border-radius: 12px;
    background: #f8f8f8; cursor: pointer; transition: all 0.2s;
  }
  .wm-btn.active {
    background: #007bff; color: white; border-color: #007bff; font-weight: bold;
  }
  /* === MODIFIED: Removed styles for controls that no longer exist === */
  /*
  .control-row { margin: 20px 0; }
  label { display: block; margin: 15px 0 8px; font-weight: 600; font-size: 1.1em; }
  input[type=range] { width: 100%; height: 10px; border-radius: 5px; background: #ddd; outline: none; }
  */
  button#mainBtn {
    background: #007bff; color: white; border: none; padding: 16px 40px; font-size: 1.1em;
    border-radius: 12px; cursor: pointer; margin-top: 10px;
  }
  button#mainBtn:disabled { background: #888; cursor: not-allowed; }
  .preview img, .preview video, .preview canvas { 
    max-width: 100%; 
    max-height: 70vh; 
    border-radius: 16px; 
    box-shadow: 0 10px 40px rgba(0,0,0,0.2); 
    background: #eee; /* BG for canvas */
  }
  .hidden { display: none; }
</style>
</head>
<body>

<h1>Professional Single Watermark Tool</h1>
<p>Perfect colors • Zero artifacts</p>

<div class="drop-zone" id="dropZone">
  Drop your photo or video here<br>or click to select
  <input type="file" id="fileInput" accept="image/*,video/*" style="display:none">
</div>

<div class="controls hidden" id="controls">
  <div class="wm-choice">
    <button type="button" class="wm-btn active" data-wm="1">Watermark Version 1</button>
    <button type="button" class="wm-btn" data-wm="2">Watermark Version 2</button>
  </div>

  <button id="mainBtn">Download Watermarked File</button>
  <div id="progress" style="margin-top:15px; font-weight:bold;"></div>
</div>

<div class="preview hidden" id="preview"></div>

<script>
// ==================== WATERMARKS ====================
const WM1_SRC = 'watermarks/watermark1.png';
const WM2_SRC = 'watermarks/watermark2.png';

// === NEW: Hardcoded values for removed controls ===
const DEFAULT_SIZE_PCT = 0.7; // 70%
const DEFAULT_OPACITY = 0.8;  // 80%

let wm1, wm2, activeWm = 1;
let currentFile, isImage = false;

// Preload both
Promise.all([loadImage(WM1_SRC), loadImage(WM2_SRC)])
  .then(imgs => { wm1 = imgs[0]; wm2 = imgs[1]; })
  .catch(err => alert('Watermarks not found! Place watermark1.png and watermark2.png in /watermarks/'));

function loadImage(src) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = rej;
    img.src = src;
  });
}

// ==================== UI ====================
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const controls = document.getElementById('controls');
const previewDiv = document.getElementById('preview');
const mainBtn = document.getElementById('mainBtn');
const progress = document.getElementById('progress');

// Drag & drop + click
dropZone.onclick = () => fileInput.click();
fileInput.onchange = e => e.target.files[0] && handleFile(e.target.files[0]);
dropZone.ondragover = dropZone.ondragenter = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
dropZone.ondragleave = dropZone.ondragend = () => dropZone.classList.remove('dragover');
dropZone.ondrop = e => {
  e.preventDefault(); dropZone.classList.remove('dragover');
  if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
};

let previewVideoElement = null;
let videoPreviewActive = false;
let previewCanvas = document.createElement('canvas'); // Reuse one canvas
const previewCtx = previewCanvas.getContext('2d');
// === NEW: Store the watermark used for the initial video preview ===
let initialWatermarkForVideo = null;


function handleFile(file) {
  currentFile = file;
  isImage = file.type.startsWith('image/');
  const url = URL.createObjectURL(file);

  videoPreviewActive = false; 
  previewVideoElement = null;

  previewDiv.innerHTML = ''; // Clear previous content
  previewDiv.classList.remove('hidden');
  controls.classList.remove('hidden');

  if (isImage) {
    const img = new Image();
    img.onload = () => {
      previewDiv.appendChild(img);
      renderPreview(); // First and *only* render for image
    };
    img.src = url;
  } else {
    previewVideoElement = document.createElement('video');
    previewVideoElement.src = url;
    previewVideoElement.muted = true;
    previewVideoElement.loop = true;
    previewVideoElement.playsInline = true;
    
    previewDiv.appendChild(previewCanvas);

    previewVideoElement.onloadedmetadata = () => {
      previewCanvas.width = previewVideoElement.videoWidth;
      previewCanvas.height = previewVideoElement.videoHeight;

      // === MODIFIED: Store the *initial* watermark ===
      initialWatermarkForVideo = activeWm === 1 ? wm1 : wm2;

      previewVideoElement.play();
      videoPreviewActive = true;
      startVideoPreviewLoop(); // Start the live render loop
    };
  }
}

// Exclusive watermark selection
document.querySelectorAll('.wm-btn').forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll('.wm-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    activeWm = parseInt(btn.dataset.wm);
    
    // === MODIFIED: Live preview is disabled ===
    // We no longer call renderPreview() for images here.
    // The video loop will ignore this change.
  };
});

// === MODIFIED: Removed 'Live sliders' event listeners ===
/*
document.getElementById('size').oninput =
document.getElementById('opacity').oninput = function() { ... };
*/

// ==================== IMAGE PREVIEW (NO ARTIFACTS) ====================
let offscreenCanvas = document.createElement('canvas'); // Reused for speed

function renderPreview() {
  if (!isImage || !wm1 || !wm2) return;

  const img = previewDiv.querySelector('img');
  const ctx = offscreenCanvas.getContext('2d');

  if (offscreenCanvas.width !== img.naturalWidth || offscreenCanvas.height !== img.naturalHeight) {
    offscreenCanvas.width = img.naturalWidth;
    offscreenCanvas.height = img.naturalHeight;
  }

  ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
  ctx.drawImage(img, 0, 0);

  // === MODIFIED: Use hardcoded values ===
  const sizePct = DEFAULT_SIZE_PCT;
  const opacity = DEFAULT_OPACITY;
  const watermark = activeWm === 1 ? wm1 : wm2; // Uses watermark active at *load time*

  drawCentered(ctx, watermark, sizePct, opacity, offscreenCanvas);

  img.src = offscreenCanvas.toDataURL('image/png');
}

// === MODIFIED: Video loop now uses the stored initial watermark ===
function startVideoPreviewLoop() {
  if (!videoPreviewActive || !previewVideoElement) return; // Stop loop if flag is false

  // 1. Clear the canvas
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

  // 2. Draw the current video frame
  previewCtx.drawImage(previewVideoElement, 0, 0, previewCanvas.width, previewCanvas.height);

  // 3. Get hardcoded settings and draw watermark
  const sizePct = DEFAULT_SIZE_PCT;
  const opacity = DEFAULT_OPACITY;
  
  // === MODIFIED: Use the watermark stored when the video was first loaded ===
  drawCentered(previewCtx, initialWatermarkForVideo, sizePct, opacity, previewCanvas);

  // 4. Request the next frame
  requestAnimationFrame(startVideoPreviewLoop);
}


function drawCentered(ctx, wmImg, scalePct, opacity, canvas) {
  const targetW = canvas.width * scalePct;
  const ratio = targetW / wmImg.width;
  const targetH = wmImg.height * ratio;
  const x = canvas.width / 2 - targetW / 2;
  const y = canvas.height / 2 - targetH / 2;

  ctx.globalAlpha = opacity;
  ctx.drawImage(wmImg, x, y, targetW, targetH);
  ctx.globalAlpha = 1;
}

// ==================== EXPORT (PERFECT MATCH) ====================
mainBtn.onclick = async () => {
  mainBtn.disabled = true;
  progress.textContent = 'Exporting...';

  if (isImage) {
    await exportImage();
  } else {
    videoPreviewActive = false; 
    if (previewVideoElement) previewVideoElement.pause();
    
    await exportVideo();

    // Resume preview
    if (previewVideoElement) previewVideoElement.play();
    videoPreviewActive = true;
    startVideoPreviewLoop(); // Restarts the loop (will use initial watermark)
  }

  mainBtn.disabled = false;
  progress.textContent = 'Download started!';
};

async function exportImage() {
  const img = await loadImage(URL.createObjectURL(currentFile));
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');

  ctx.drawImage(img, 0, 0);

  // === MODIFIED: Use hardcoded values ===
  const sizePct = DEFAULT_SIZE_PCT;
  const opacity = DEFAULT_OPACITY;
  // Export *does* use the currently selected watermark
  const watermark = activeWm === 1 ? wm1 : wm2;

  drawCentered(ctx, watermark, sizePct, opacity, canvas);

  canvas.toBlob(blob => download(blob, 'watermarked.png'), 'image/png');
}

async function exportVideo() {
  const video = document.createElement('video');
  video.src = URL.createObjectURL(currentFile);
  await new Promise(r => video.onloadedmetadata = r);

  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  const ctx = canvas.getContext('2d');

  const stream = canvas.captureStream(30); // 30 FPS
  const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => download(new Blob(chunks, {type: 'video/webm'}), 'watermarked.webm');

  // === MODIFIED: Use hardcoded values ===
  const sizePct = DEFAULT_SIZE_PCT;
  const opacity = DEFAULT_OPACITY;
  // Export *does* use the currently selected watermark
  const watermark = activeWm === 1 ? wm1 : wm2;

  recorder.start();
  video.currentTime = 0;
  video.muted = true; // Ensure export is silent
  video.play();

  let drawFrame;
  drawFrame = () => {
    if (video.paused || video.ended) {
      recorder.stop();
      return;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height); 
    ctx.drawImage(video, 0, 0);
    drawCentered(ctx, watermark, sizePct, opacity, canvas);
    
    requestAnimationFrame(drawFrame); 
  };
  
  drawFrame();
}

function download(blob, name) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href); // Clean up
}
</script>
</body>
</html>
