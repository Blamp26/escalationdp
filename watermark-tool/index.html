<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image & Watermark Studio — vertical-fill watermark</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#60a5fa}
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,Arial;background:linear-gradient(180deg,#081224 0%, #071423 100%);color:#e6eef6}
  .app{max-width:1100px;margin:28px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.7)}
  header{display:flex;gap:12px;align-items:center}
  h1{font-size:20px;margin:0}
  .layout{display:grid;grid-template-columns:380px 1fr;gap:18px;margin-top:16px}
  .panel{background:var(--card);padding:12px;border-radius:10px}
  label{display:block;font-size:13px;margin:8px 0 6px;color:var(--muted)}
  input[type=file]{width:100%}
  select,input,button{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .row{display:flex;gap:8px}
  .preview-wrap{display:flex;flex-direction:column;align-items:center;gap:10px}
  #previewCanvas{background:#08121a;border-radius:6px;max-width:100%;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02)}
  .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .muted{color:var(--muted);font-size:13px}
  .btn{background:linear-gradient(90deg,var(--accent),#3b82f6);border:none;color:#05233a;padding:8px;border-radius:8px;cursor:pointer}
  .small{font-size:13px;padding:6px}
  .footer{margin-top:10px;font-size:13px;color:var(--muted)}
  .watermark-list{display:flex;gap:8px}
  .wm-thumb{width:60px;height:40px;border-radius:6px;object-fit:contain;cursor:pointer;border:2px solid transparent}
  .wm-thumb.selected{border-color:#60a5fa}
  .hint{font-size:12px;color:#9fb0c8}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Image & Watermark Studio</h1>
    <div class="muted">Водяной знак всегда по центру и заполняет по вертикали (может выходить за стороны по горизонтали).</div>
  </header>

  <div class="layout">
    <div class="panel" style="height:720px;overflow:auto">
      <label>1) Загрузите фото</label>
      <input id="fileInput" type="file" accept="image/*,video/*" />
      <div class="hint">Поддерживаемые форматы: JPEG, PNG, WebP. Видео: MP4/WebM (используется как источник для превью/видео-экспорта).</div>

      <label>2) Выберите водяной знак</label>
      <div class="watermark-list" id="wmList">
        <!-- thumbnails populated by script -->
      </div>
      <label class="muted">Или загрузите свой файл вотермарки (ожидается 1920×1080). Он будет масштабироваться так, чтобы заполнять высоту фото.</label>
      <input id="wmUpload" type="file" accept="image/*" />

      <label>Настройки</label>
      <div class="muted">Прозрачность и ручная настройка размера отключены: вотермарка автоматически масштабируется по высоте исходного изображения и центрируется.</div>

      <label>Экспорт</label>
      <div class="row">
        <button class="btn" id="exportImage">Экспорт PNG</button>
        <button class="btn" id="exportJpeg">Экспорт JPEG</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button class="btn" id="exportVideo">Экспорт WebM (3s анимация)</button>
        <button class="small" id="reset">Сброс</button>
      </div>

      <div class="footer">Водяной знак будет располагаться строго по центру вертикали. Для корректной работы внешние изображения должны иметь CORS-заголовки.</div>
    </div>

    <div class="panel preview-wrap">
      <label class="muted">Превью</label>
      <div id="previewHolder" style="width:100%;height:640px;display:flex;align-items:center;justify-content:center;position:relative;padding:0;margin:0">
        <canvas id="previewCanvas"></canvas>
        <div id="overlayHint" style="position:absolute;right:8px;bottom:8px;background:rgba(2,6,23,0.6);padding:6px;border-radius:6px;font-size:12px;color:var(--muted)">Водяной знак центрируется и масштабируется по высоте</div>
      </div>

      <div style="width:100%;display:flex;gap:8px;margin-top:10px;align-items:center">
        <div style="flex:1">
          <div class="muted">Изображение:</div>
          <div id="imageInfo" class="muted">No image loaded</div>
        </div>
        <div style="width:220px">
          <div class="muted">Водяной знак (центр)</div>
          <div id="posInfo" class="muted">-</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
const watermarkPaths = [
  'watermark-tool/watermarks/watermark1.png',
  'watermark-tool/watermarks/watermark2.png'
];

// UI refs
const fileInput = document.getElementById('fileInput');
const previewCanvas = document.getElementById('previewCanvas');
const previewCtx = previewCanvas.getContext('2d');
const wmList = document.getElementById('wmList');
const wmUpload = document.getElementById('wmUpload');
const exportImageBtn = document.getElementById('exportImage');
const exportJpegBtn = document.getElementById('exportJpeg');
const exportVideoBtn = document.getElementById('exportVideo');
const resetBtn = document.getElementById('reset');
const imageInfo = document.getElementById('imageInfo');
const posInfo = document.getElementById('posInfo');

let srcImage = null;
let srcVideo = null;
let watermarkImg = null;
let watermarkSelection = null;
let srcWidth = 0, srcHeight = 0;
let offscreenCanvas = document.createElement('canvas');
let offscreenCtx = offscreenCanvas.getContext('2d');

// watermark state (fixed)
const wmState = {opacity:1, rotation:0};
let previewScale = 1;

function createWatermarkThumbnails(){
  watermarkPaths.forEach((p,i)=>{
    const img = document.createElement('img');
    img.src = p;
    img.className = 'wm-thumb';
    img.title = p;
    img.onclick = ()=>selectWatermark(p,img);
    wmList.appendChild(img);
  });
}

function selectWatermark(path,thumbEl){
  watermarkSelection = {type:'path',src:path};
  document.querySelectorAll('.wm-thumb').forEach(t=>t.classList.remove('selected'));
  if(thumbEl) thumbEl.classList.add('selected');
  loadWatermark(path);
}

function loadWatermark(src){
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    watermarkImg = img;
    renderPreview();
  };
  img.onerror = ()=>{ alert('Не удалось загрузить вотермарку: '+src); }
  if(typeof src === 'string') img.src = src;
  else img.src = URL.createObjectURL(src);
}

wmUpload.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  watermarkSelection = {type:'file',file:f};
  loadWatermark(f);
});

fileInput.addEventListener('change', async e=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  if(f.type.startsWith('image/')){
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=>{
      srcImage = img;
      srcWidth = img.naturalWidth;
      srcHeight = img.naturalHeight;
      offscreenCanvas.width = srcWidth; offscreenCanvas.height = srcHeight;
      updateInfo(); fitPreviewCanvas(); renderPreview();
    };
    img.src = url;
  } else if(f.type.startsWith('video/')){
    const vid = document.createElement('video');
    vid.src = url; vid.muted = true; vid.loop = true; vid.autoplay = true; vid.playsInline = true;
    vid.onloadeddata = ()=>{
      srcVideo = vid;
      srcWidth = vid.videoWidth; srcHeight = vid.videoHeight;
      offscreenCanvas.width = srcWidth; offscreenCanvas.height = srcHeight;
      updateInfo(); fitPreviewCanvas(); renderPreview(); vid.play();
    }
  }
});

function fitPreviewCanvas(){
  const holder = document.getElementById('previewHolder');
  const maxW = holder.clientWidth-0; // no offset
  const maxH = 640-0;
  if(!srcWidth || !srcHeight){ previewCanvas.width = 800; previewCanvas.height = 450; previewScale = 1; return; }
  const scale = Math.min(maxW/srcWidth, maxH/srcHeight, 1);
  previewScale = scale;
  previewCanvas.width = Math.round(srcWidth*scale);
  previewCanvas.height = Math.round(srcHeight*scale);
  previewCanvas.style.width = previewCanvas.width+'px';
  previewCanvas.style.height = previewCanvas.height+'px';
}

function updateInfo(){
  if(srcWidth) imageInfo.textContent = `Source: ${srcWidth} × ${srcHeight} px`;
  else imageInfo.textContent = 'No image loaded';
}

function clearPreview(){ previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height); }

// New behaviour: watermark scales to MATCH image height (fills vertically). It may overflow horizontally.
function computeWatermarkFit(){
  if(!watermarkImg || !srcWidth || !srcHeight) return null;
  // scale so watermark height equals source height
  const scaleFactor = srcHeight / watermarkImg.naturalHeight;
  const w = Math.round(watermarkImg.naturalWidth * scaleFactor);
  const h = Math.round(watermarkImg.naturalHeight * scaleFactor); // should equal srcHeight (rounding aside)
  return {w,h};
}

function renderPreview(){
  clearPreview();
  if(!srcWidth || !srcHeight) return;
  if(srcImage) previewCtx.drawImage(srcImage, 0, 0, srcWidth*previewScale, srcHeight*previewScale);
  else if(srcVideo){ try{ previewCtx.drawImage(srcVideo,0,0,srcWidth*previewScale,srcHeight*previewScale); } catch(e){} }

  if(!watermarkImg) return;
  const fit = computeWatermarkFit();
  if(!fit) return;
  // display sizes
  const displayW = fit.w * previewScale;
  const displayH = fit.h * previewScale; // ~ srcHeight*previewScale

  // center in preview coords
  const cx = previewCanvas.width/2;
  const cy = previewCanvas.height/2;

  previewCtx.save();
  previewCtx.globalAlpha = wmState.opacity; // always 1
  previewCtx.globalCompositeOperation = 'source-over';
  previewCtx.translate(cx, cy);
  previewCtx.rotate(wmState.rotation * Math.PI/180);
  previewCtx.drawImage(watermarkImg, -displayW/2, -displayH/2, displayW, displayH);
  previewCtx.restore();

  posInfo.textContent = `center x:${Math.round(srcWidth/2)} y:${Math.round(srcHeight/2)} — size ${fit.w}×${fit.h}`;
}

function compositeToOffscreen(customDrawCallback){
  if(!srcWidth || !srcHeight) throw new Error('No source loaded');
  offscreenCtx.clearRect(0,0,offscreenCanvas.width, offscreenCanvas.height);
  if(srcImage) offscreenCtx.drawImage(srcImage, 0, 0, srcWidth, srcHeight);
  else if(srcVideo){ try{ offscreenCtx.drawImage(srcVideo,0,0,srcWidth,srcHeight); } catch(e){} }

  if(watermarkImg){
    const fit = computeWatermarkFit();
    const w = fit.w; const h = fit.h; // h ≈ srcHeight
    offscreenCtx.save();
    offscreenCtx.globalAlpha = wmState.opacity; // 1
    offscreenCtx.globalCompositeOperation = 'source-over';
    offscreenCtx.translate(srcWidth/2, srcHeight/2);
    offscreenCtx.rotate(wmState.rotation * Math.PI/180);
    offscreenCtx.drawImage(watermarkImg, -w/2, -h/2, w, h);
    offscreenCtx.restore();
  }
  if(typeof customDrawCallback === 'function') customDrawCallback(offscreenCtx);
}

exportImageBtn.addEventListener('click', ()=>{
  try{ if(!srcWidth) return alert('No source loaded'); compositeToOffscreen(); offscreenCanvas.toBlob(blob=>{ const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'watermarked.png'; a.click(); }, 'image/png'); }catch(e){ alert('Export failed: '+e.message); }
});

exportJpegBtn.addEventListener('click', ()=>{
  try{ if(!srcWidth) return alert('No source loaded'); compositeToOffscreen(); offscreenCanvas.toBlob(blob=>{ const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'watermarked.jpg'; a.click(); }, 'image/jpeg', 0.92); }catch(e){ alert('Export failed: '+e.message); }
});

exportVideoBtn.addEventListener('click', ()=>{
  if(!srcWidth) return alert('No source loaded'); exportVideo({duration:3000, fps:30}).then(url=>{ const a = document.createElement('a'); a.href = url; a.download = 'watermarked.webm'; a.click(); }).catch(e=>alert('Video export failed: '+e.message));
});

async function exportVideo({duration=3000,fps=30} = {}){
  return new Promise((resolve,reject)=>{
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = srcWidth; tempCanvas.height = srcHeight;
    const tctx = tempCanvas.getContext('2d');
    const totalFrames = Math.round(duration/1000 * fps);
    let currentFrame = 0;
    const baseRotation = wmState.rotation;

    // compute fit once (height-fill)
    const fit = computeWatermarkFit();
    const startScale = 0.995; const endScale = 1.005; // very subtle pulse

    const stream = tempCanvas.captureStream(fps);
    const recordedChunks = [];
    let recorder;
    try{ recorder = new MediaRecorder(stream, {mimeType: 'video/webm; codecs=vp9'}); }catch(err){ try{ recorder = new MediaRecorder(stream, {mimeType: 'video/webm; codecs=vp8'}); }catch(e){ return reject(err); }}
    recorder.ondataavailable = ev=>{ if(ev.data && ev.data.size) recordedChunks.push(ev.data); };
    recorder.onstop = ()=>{ const blob = new Blob(recordedChunks, {type:'video/webm'}); const url = URL.createObjectURL(blob); resolve(url); };
    recorder.start();

    function drawFrame(){
      const t = currentFrame/Math.max(1,totalFrames-1);
      const ease = (1 - Math.cos(Math.PI * t)) / 2;
      if(srcImage) tctx.drawImage(srcImage,0,0,srcWidth,srcHeight);
      else if(srcVideo){ try{ tctx.drawImage(srcVideo,0,0,srcWidth,srcHeight); }catch(e){} }
      // watermark subtle scale pulse around full-height
      const scale = startScale + (endScale-startScale)*ease;
      if(watermarkImg){
        const w = Math.round(fit.w * scale);
        const h = Math.round(fit.h * scale);
        tctx.save(); tctx.globalAlpha = wmState.opacity; tctx.globalCompositeOperation = 'source-over'; tctx.translate(srcWidth/2, srcHeight/2); tctx.rotate(baseRotation * Math.PI/180); tctx.drawImage(watermarkImg, -w/2, -h/2, w, h); tctx.restore();
      }
      currentFrame++;
      if(currentFrame <= totalFrames) requestAnimationFrame(drawFrame);
      else setTimeout(()=>{ recorder.stop(); }, 200);
    }
    drawFrame();
  });
}

resetBtn.addEventListener('click', ()=>{ srcImage=null; srcVideo=null; watermarkImg=null; watermarkSelection=null; srcWidth=0; srcHeight=0; offscreenCanvas.width=offscreenCanvas.height=1; previewCanvas.width=previewCanvas.height=1; imageInfo.textContent='No image loaded'; posInfo.textContent='-'; document.querySelectorAll('.wm-thumb').forEach(t=>t.classList.remove('selected')); });

createWatermarkThumbnails(); updateInfo();
</script>
</body>
</html>
