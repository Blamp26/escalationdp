<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Real-Time Full-Size Center Watermark Tool</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: system-ui, sans-serif; max-width: 1000px; margin: 2rem auto; padding: 1rem; background:#f5f7fa; text-align:center; }
  h1 { margin-bottom: 0.5em; color: #222; }
  .drop-zone {
    border: 4px dashed #555;
    border-radius: 20px;
    padding: 80px 20px;
    background: white;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 1.3em;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }
  .drop-zone:hover, .drop-zone.dragover { border-color: #007bff; background:#f0f8ff; }
  .controls { margin: 30px 0; padding: 25px; background:white; border-radius:16px; box-shadow:0 6px 30px rgba(0,0,0,0.12); }
  .control-row { margin: 20px 0; }
  label { display: block; margin: 15px 0 8px; font-weight: 600; font-size: 1.1em; }
  input[type=range] { width: 100%; height: 10px; border-radius: 5px; background: #ddd; outline: none; }
  select, button {
    padding: 12px 20px; font-size: 1.1em; border-radius: 8px; margin: 10px;
  }
  button#mainBtn {
    background: #007bff; color: white; border: none; padding: 16px 40px; cursor: pointer;
  }
  button#mainBtn:hover { background: #0056b3; }
  button#mainBtn:disabled { background: #888; cursor: not-allowed; }
  .preview { margin: 30px 0; }
  .preview img, .preview video { max-width: 100%; max-height: 70vh; border-radius: 16px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); }
  .hidden { display: none; }
  .mode-buttons button {
    background: #eee; border: 2px solid #ddd; padding: 10px 20px;
  }
  .mode-buttons button.active { background: #007bff; color: white; border-color: #007bff; }
</style>
</head>
<body>

<h1>Real-Time Full-Size Center Watermark</h1>
<div class="drop-zone" id="dropZone">
  Drop your photo or video here<br>or click to select
  <input type="file" id="fileInput" accept="image/*,video/*" style="display:none">
</div>

<div class="controls hidden" id="controls">
  <div class="control-row mode-buttons">
    <button type="button" class="active" data-mode="both">Both Watermarks</button>
    <button type="button" data-mode="wm1">Watermark 1 Only</button>
    <button type="button" data-mode="wm2">Watermark 2 Only</button>
  </div>

  <div class="control-row">
    <label>Watermark Size: <span id="sizeVal">65</span>% of width</label>
    <input type="range" min="10" max="100" value="65" id="size">
  </div>

  <div class="control-row">
    <label>Opacity: <span id="opacityVal">75</span>%</label>
    <input type="range" min="0" max="100" value="75" id="opacity">
  </div>

  <button id="mainBtn">Download Watermarked File</button>
  <div id="progress" style="margin-top:15px; font-weight:bold;"></div>
</div>

<div class="preview hidden" id="preview"></div>

<script>
// ==================== WATERMARKS ====================
const WM1_SRC = 'watermarks/watermark1.png';  // Your main logo/text
const WM2_SRC = 'watermarks/watermark2.png';  // Alternative version

let wm1, wm2;
let currentFile, isImage = false;
let currentMode = 'both'; // both | wm1 | wm2

// Preload both watermarks
Promise.all([loadImage(WM1_SRC), loadImage(WM2_SRC)])
  .then(imgs => { wm1 = imgs[0]; wm2 = imgs[1]; })
  .catch(() => alert('Error loading watermarks. Make sure watermark1.png and watermark2.png exist in /watermarks/'));

function loadImage(src) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = rej;
    img.src = src;
  });
}

// ==================== UI ====================
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const controls = document.getElementById('controls');
const previewDiv = document.getElementById('preview');
const mainBtn = document.getElementById('mainBtn');
const progress = document.getElementById('progress');

dropZone.onclick = () => fileInput.click();
fileInput.onchange = e => e.target.files[0] && handleFile(e.target.files[0]);

dropZone.ondragover = dropZone.ondragenter = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
dropZone.ondragleave = dropZone.ondragend = () => dropZone.classList.remove('dragover');
dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
};

function handleFile(file) {
  currentFile = file;
  isImage = file.type.startsWith('image/');
  const url = URL.createObjectURL(file);

  previewDiv.innerHTML = '';
  previewDiv.classList.remove('hidden');
  controls.classList.remove('hidden');

  if (isImage) {
    const img = new Image();
    img.onload = () => {
      previewDiv.appendChild(img);
      renderPreview(); // First draw
    };
    img.src = url;
  } else {
    const video = document.createElement('video');
    video.src = url;
    video.controls = true;
    video.muted = true;
    previewDiv.appendChild(video);
  }
}

// Mode selector
document.querySelectorAll('.mode-buttons button').forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll('.mode-buttons button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentMode = btn.dataset.mode;
    if (isImage) renderPreview();
  };
});

// Real-time controls
document.getElementById('size').oninput =
document.getElementById('opacity').oninput = function() {
  const val = this.value;
  document.getElementById(this.id + 'Val').textContent = val;
  if (isImage) renderPreview();
};

// ==================== REAL-TIME PREVIEW (Images) ====================
function renderPreview() {
  if (!isImage || !wm1) return;

  const img = previewDiv.querySelector('img');
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  ctx.drawImage(img, 0, 0);

  const sizePct = document.getElementById('size').value / 100;
  const opacity = document.getElementById('opacity').value / 100;

  if (currentMode === 'both' || currentMode === 'wm1') {
    drawFullCenter(ctx, wm1, sizePct, opacity, canvas);
  }
  if (currentMode === 'both' || currentMode === 'wm2') {
    drawFullCenter(ctx, wm2, sizePct, opacity, canvas);
  }

  img.src = canvas.toDataURL('image/jpeg', 0.95);
}

// Draw watermark centered, scaled to % of canvas width
function drawFullCenter(ctx, wmImg, scalePct, opacity, canvas) {
  const targetWidth = canvas.width * scalePct;
  const ratio = targetWidth / wmImg.width;
  const h = wmImg.height * ratio;

  const x = canvas.width / 2 - targetWidth / 2;
  const y = canvas.height / 2 - h / 2;

  ctx.globalAlpha = opacity;
  ctx.drawImage(wmImg, x, y, targetWidth, h);
  ctx.globalAlpha = 1;
}

// ==================== DOWNLOAD ====================
mainBtn.onclick = async () => {
  mainBtn.disabled = true;
  progress.textContent = 'Processing...';

  if (isImage) {
    await processImage();
  } else {
    await processVideoSimple(); // Fast canvas export
  }

  mainBtn.disabled = false;
  progress.textContent = 'Done! Download started.';
};

async function processImage() {
  const img = await loadImage(URL.createObjectURL(currentFile));
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);

  const sizePct = document.getElementById('size').value / 100;
  const opacity = document.getElementById('opacity').value / 100;

  if (currentMode === 'both' || currentMode === 'wm1') drawFullCenter(ctx, wm1, sizePct, opacity, canvas);
  if (currentMode === 'both' || currentMode === 'wm2') drawFullCenter(ctx, wm2, sizePct, opacity, canvas);

  canvas.toBlob(blob => download(blob, 'watermarked.jpg'), 'image/jpeg', 0.95);
}

// Fast & compatible video export using canvas + MediaRecorder
async function processVideoSimple() {
  const video = document.createElement('video');
  video.src = URL.createObjectURL(currentFile);
  await new Promise(r => video.onloadedmetadata = r);

  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  const ctx = canvas.getContext('2d');

  const stream = canvas.captureStream(30);
  const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => download(new Blob(chunks, {type: 'video/webm'}), 'watermarked.webm');

  const sizePct = document.getElementById('size').value / 100;
  const opacity = document.getElementById('opacity').value / 100;

  recorder.start();
  video.currentTime = 0;
  video.play();

  function draw() {
    if (video.ended || video.paused) {
      recorder.stop();
      return;
    }
    ctx.drawImage(video, 0, 0);
    if (currentMode === 'both' || currentMode === 'wm1') drawFullCenter(ctx, wm1, sizePct, opacity, canvas);
    if (currentMode === 'both' || currentMode === 'wm2') drawFullCenter(ctx, wm2, sizePct, opacity, canvas);
    requestAnimationFrame(draw);
  }

  video.onplay = draw;
  video.onended = () => recorder.stop();
}

function download(blob, name) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
}
</script>
</body>
</html>
