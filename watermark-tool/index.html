<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fast Center Dual Watermark Tool</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: system-ui, sans-serif; max-width: 1000px; margin: 2rem auto; padding: 1rem; background:#f4f4f9; text-align:center; }
  h1 { margin-bottom: 0.5em; }
  .drop-zone {
    border: 4px dashed #666;
    border-radius: 16px;
    padding: 60px;
    background: white;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 1.2em;
  }
  .drop-zone:hover, .drop-zone.dragover { border-color: #007bff; background:#f0f7ff; }
  .controls { margin: 30px 0; padding: 20px; background:white; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.1); }
  .slider-group { margin: 20px 0; }
  label { display: block; margin: 15px 0 8px; font-weight: 600; }
  input[type=range] { width: 100%; height: 8px; border-radius: 5px; background: #ddd; outline: none; }
  .preview { margin: 30px 0; }
  video, img { max-width: 100%; max-height: 70vh; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.15); }
  button { padding: 14px 32px; font-size: 1.1em; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 20px; }
  button:hover { background: #0056b3; }
  button:disabled { background: #666; cursor: not-allowed; }
  .hidden { display: none; }
</style>
</head>
<body>

<h1>Ultra-Fast Center Watermark Tool</h1>
<div class="drop-zone" id="dropZone">
  Drop photo or video here<br>or click to upload
  <input type="file" id="fileInput" accept="image/*,video/*" style="display:none">
</div>

<div class="controls hidden" id="controls">
  <div class="slider-group">
    <label>Watermark 1 Opacity: <span id="op1Val">70</span>%</label>
    <input type="range" min="0" max="100" value="70" id="opacity1">
    
    <label>Watermark 1 Size: <span id="size1Val">18</span>%</label>
    <input type="range" min="5" max="40" value="18" id="size1">
  </div>

  <div class="slider-group">
    <label>Watermark 2 Opacity: <span id="op2Val">50</span>%</label>
    <input type="range" min="0" max="100" value="50" id="opacity2">
    
    <label>Watermark 2 Size: <span id="size2Val">12</span>%</label>
    <input type="range" min="5" max="40" value="12" id="size2">
  </div>

  <button id="processBtn">Apply Watermarks & Download</button>
  <div id="progress"></div>
</div>

<div class="preview hidden" id="preview"></div>

<script>
// ==================== CONFIG ====================
const WM1_SRC = 'watermarks/watermark1.png';
const WM2_SRC = 'watermarks/watermark2.png';

let wm1, wm2;
let originalFile;
let isImage = false;

// Load watermarks once
Promise.all([loadImage(WM1_SRC), loadImage(WM2_SRC)])
  .then(imgs => { wm1 = imgs[0]; wm2 = imgs[1]; })
  .catch(() => alert('Error: Could not load watermarks. Check /watermarks/watermark1.png and watermark2.png'));

function loadImage(src) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = rej;
    img.src = src;
  });
}

// ==================== UI ====================
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const controls = document.getElementById('controls');
const previewDiv = document.getElementById('preview');
const processBtn = document.getElementById('processBtn');
const progress = document.getElementById('progress');

dropZone.onclick = () => fileInput.click();
fileInput.onchange = e => e.target.files[0] && handleFile(e.target.files[0]);

dropZone.ondragover = dropZone.ondragenter = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
dropZone.ondragleave = dropZone.ondragend = () => dropZone.classList.remove('dragover');
dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
};

function handleFile(file) {
  originalFile = file;
  isImage = file.type.startsWith('image/');
  const url = URL.createObjectURL(file);

  previewDiv.innerHTML = '';
  previewDiv.classList.remove('hidden');
  controls.classList.remove('hidden');

  if (isImage) {
    const img = new Image();
    img.onload = () => {
      previewDiv.appendChild(img);
      drawPreview(img); // initial draw
    };
    img.src = url;
  } else {
    const video = document.createElement('video');
    video.src = url;
    video.controls = true;
    video.muted = true;
    previewDiv.appendChild(video);
  }
}

// Debounced preview (only for images) — huge performance win
let previewTimeout;
function drawPreview(baseImg) {
  if (!isImage || !wm1 || !wm2) return;

  clearTimeout(previewTimeout);
  previewTimeout = setTimeout(() => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = baseImg.naturalWidth;
    canvas.height = baseImg.naturalHeight;

    ctx.drawImage(baseImg, 0, 0);

    const o1 = document.getElementById('opacity1').value / 100;
    const s1 = document.getElementById('size1').value / 100;
    const o2 = document.getElementById('opacity2').value / 100;
    const s2 = document.getElementById('size2').value / 100;

    drawCenteredWatermark(ctx, wm1, o1, s1, canvas);
    drawCenteredWatermark(ctx, wm2, o2, s2, canvas);

    previewDiv.querySelector('img').src = canvas.toDataURL('image/jpeg', 0.92);
  }, 150); // 150ms debounce = buttery smooth, no lag
}

// Update preview only on input (with debounce)
['opacity1','size1','opacity2','size2'].forEach(id => {
  document.getElementById(id).addEventListener('input', () => {
    document.getElementById(id + 'Val').textContent = document.getElementById(id).value;
    if (isImage && previewDiv.querySelector('img')) {
      drawPreview(previewDiv.querySelector('img'));
    }
  });
});

// ==================== PROCESSING (SUPER FAST) ====================
processBtn.onclick = async () => {
  processBtn.disabled = true;
  progress.textContent = 'Processing...';

  if (isImage) {
    await processImageFast();
  } else {
    await processVideoFast();
  }

  processBtn.disabled = false;
  progress.textContent = 'Done! Download started.';
};

async function processImageFast() {
  const img = await loadImage(URL.createObjectURL(originalFile));
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);

  const o1 = document.getElementById('opacity1').value / 100;
  const s1 = document.getElementById('size1').value / 100;
  const o2 = document.getElementById('opacity2').value / 100;
  const s2 = document.getElementById('size2').value / 100;

  drawCenteredWatermark(ctx, wm1, o1, s1, canvas);
  drawCenteredWatermark(ctx, wm2, o2, s2, canvas);

  canvas.toBlob(blob => download(blob, 'watermarked.jpg'), 'image/jpeg', 0.95);
}

// Fast video: use ffmpeg.wasm (tiny build) — best performance/compability trade-off
async function processVideoFast() {
  if (!window.FFmpeg) {
    progress.textContent = 'Loading fast video engine... (first time only)';
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({ log: false, corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js' });
    window.ffmpeg = ffmpeg;
    await ffmpeg.load();
  }

  const ffmpeg = window.ffmpeg;
  ffmpeg.FS('writeFile', 'input', await fetchFile(originalFile));
  ffmpeg.FS('writeFile', 'wm1.png', await fetchFile(wm1.src));
  ffmpeg.FS('writeFile', 'wm2.png', await fetchFile(wm2.src));

  const o1 = document.getElementById('opacity1').value / 100;
  const s1 = document.getElementById('size1').value / 100;
  const o2 = document.getElementById('opacity2').value / 100;
  const s2 = document.getElementById('size2').value / 100;

  const filter = [
    `[0:v]scale=iw*min(1920/iw\\,1080/ih):-2[base];`,
    `[base][1:v]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:format=auto:enable='between(t,0,999)'[v1];`,
    `[v1][2:v]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:format=auto`,
    `:opacity=${o1 * 100 / 100}[v2];`,
    `[v2]scale=iw:-2` // maintain aspect ratio
  ].join('');

  // Complexily add opacity via format=rgba + colorchannelmixer
  const cmd = [
    '-i', 'input',
    '-i', 'wm1.png',
    '-i', 'wm2.png',
    '-filter_complex', `${filter};[v2]format=yuv420p[outv]`,
    '-map', '[outv]', '-map', '0:a?', '-c:v', 'libx264', '-preset', 'fast', '-crf', '23',
    '-movflags', '+faststart', 'output.mp4'
  ];

  ffmpeg.setProgress(({ ratio }) => {
    progress.textContent = `Processing video: ${(ratio * 100).toFixed(1)}%`;
  });

  await ffmpeg.run(...cmd);

  const data = ffmpeg.FS('readFile', 'output.mp4');
  download(new Blob([data.buffer], { type: 'video/mp4' }), 'watermarked.mp4');
}

// Centered watermark only
function drawCenteredWatermark(ctx, wmImg, opacity, scale, canvas) {
  if (!wmImg) return;
  const w = canvas.width * scale;
  const h = wmImg.height / wmImg.width * w;
  const x = canvas.width / 2 - w / 2;
  const y = canvas.height / 2 - h / 2;

  ctx.globalAlpha = opacity;
  ctx.drawImage(wmImg, x, y, w, h);
  ctx.globalAlpha = 1;
}

function download(blob, name) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
}
</script>

<!-- FFmpeg.wasm (only loaded when needed) -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
</body>
</html>
