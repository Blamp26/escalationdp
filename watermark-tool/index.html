<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Watermark studio — hi-quality (images only) — optimized</title>
<style>
:root{--card:#0b1220;--muted:#9aa4b2;--accent:#60a5fa}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:#071423;color:#e6eef6}
.app{max-width:1100px;margin:20px auto;padding:14px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.6)}
header{display:flex;gap:12px;align-items:center}
h1{font-size:18px;margin:0}
.layout{display:grid;grid-template-columns:360px 1fr;gap:14px;margin-top:12px}
.panel{background:var(--card);padding:12px;border-radius:10px}
label{display:block;font-size:13px;margin:8px 0 6px;color:var(--muted)}
input[type=file],select,input,button{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
.row{display:flex;gap:8px}
.preview-wrap{display:flex;flex-direction:column;align-items:center;gap:10px}
#previewCanvas{background:#08121a;border-radius:6px;max-width:100%;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02)}
.muted{color:var(--muted);font-size:13px}
.btn{background:linear-gradient(90deg,var(--accent),#3b82f6);border:none;color:#05233a;padding:8px;border-radius:8px;cursor:pointer}
.wm-thumb{width:60px;height:40px;border-radius:6px;object-fit:contain;cursor:pointer;border:2px solid transparent}
.wm-thumb.selected{border-color:#60a5fa}
.status-on{color:#c7f9d9}
.status-off{color:#ffc7c7}
.hint{font-size:12px;color:#9fb0c8}
.color-selector{display:flex;gap:8px;margin-bottom:8px}
.color-option{padding:6px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.1);cursor:pointer;font-size:12px}
.color-option.selected{background:var(--accent);color:#05233a;border-color:var(--accent)}
.export-options{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.export-row{display:flex;gap:8px}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Watermark studio — hi-quality (images only)</h1>
    <div class="muted">Экспорт сохраняет исходное качество изображения</div>
  </header>

  <div class="layout">
    <div class="panel" style="height:720px;overflow:auto">
      <label>1) Загрузите фото (локально)</label>
      <input id="fileInput" type="file" accept="image/*" />
      <div class="hint">Локальные файлы надёжно позволяют читать пиксели.</div>

      <label>2) Выберите или загрузите водяной знак</label>
      <div id="wmList" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px"></div>
      <input id="wmUpload" type="file" accept="image/*" />
      <div class="hint">Выберите водяной знак из коллекции или загрузите свой PNG с прозрачным фоном</div>

      <label>Настройки водяного знака</label>
      <div style="margin-bottom:12px">
        <div class="muted" style="margin-bottom:6px">Режим цвета:</div>
        <div class="color-selector">
          <div class="color-option selected" data-color="adaptive">Адаптивный (умный)</div>
          <div class="color-option" data-color="light">Светлый</div>
          <div class="color-option" data-color="dark">Темный</div>
        </div>
        <div class="hint">Адаптивный режим меняет цвет водяного знака в зависимости от фона под каждой его частью</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <div class="muted">Адаптация цвета:</div>
        <div id="adaptFlag" class="muted">UNKNOWN</div>
      </div>

      <label>Информация об изображении</label>
      <div id="imageInfo" class="muted">Загрузите изображение чтобы увидеть параметры</div>

      <label>Экспорт</label>
      <div class="export-options">
        <div class="export-row">
          <button class="btn" id="exportPng">PNG</button>
          <button class="btn" id="exportJpg">JPG</button>
        </div>
        <div class="export-row">
          <button class="btn" id="reset">Сброс</button>
        </div>
      </div>

      <div class="muted" style="margin-top:8px">
        <div>Экспорт сохраняет исходные параметры изображения.</div>
      </div>
    </div>

    <div class="panel preview-wrap">
      <label class="muted">Превью</label>
      <div id="previewHolder" style="width:100%;height:640px;display:flex;align-items:center;justify-content:center;position:relative">
        <canvas id="previewCanvas"></canvas>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
        <div style="flex:1"><div class="muted">Source:</div><div id="imageInfoShort" class="muted">No source</div></div>
        <div style="width:280px"><div class="muted">Info:</div><div id="posInfo" class="muted">-</div></div>
      </div>

      <div id="exportProgress" style="display:none;margin-top:10px;width:100%">
        <div class="muted">Прогресс экспорта:</div>
        <div style="background:#0b1220;border-radius:4px;overflow:hidden;margin-top:4px">
          <div id="progressBar" style="height:6px;background:var(--accent);width:0%;transition:width 0.3s"></div>
        </div>
        <div id="progressText" class="muted" style="font-size:12px;text-align:center;margin-top:4px">0%</div>
        <div id="timeRemaining" class="muted" style="font-size:12px;text-align:center;margin-top:2px"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* =================== OPTIMIZED JS ===================
   Основные подходы:
   - рендер только по событиям (без RAF loop)
   - reuse одного tempCanvas и одного wmCanvas
   - кеш адаптивных результатов по size+mode
   - минимум createElement('canvas') и getImageData
*/

const watermarkPaths = [
  'https://raw.githubusercontent.com/Blamp26/escalationdp/main/watermark-tool/watermarks/watermark1.png',
  'https://raw.githubusercontent.com/Blamp26/escalationdp/main/watermark-tool/watermarks/watermark2.png'
];

const fileInput = document.getElementById('fileInput');
const wmUpload = document.getElementById('wmUpload');
const wmList = document.getElementById('wmList');
const previewCanvas = document.getElementById('previewCanvas');
const previewCtx = previewCanvas.getContext('2d', {alpha:true});
const adaptFlag = document.getElementById('adaptFlag');
const imageInfo = document.getElementById('imageInfo');
const imageInfoShort = document.getElementById('imageInfoShort');
const posInfo = document.getElementById('posInfo');
const exportPng = document.getElementById('exportPng');
const exportJpg = document.getElementById('exportJpg');
const resetBtn = document.getElementById('reset');
const previewHolder = document.getElementById('previewHolder');
const colorOptions = document.querySelectorAll('.color-option');

let srcImage = null;
let srcWidth = 0, srcHeight = 0;
let watermarkBitmap = null;
let watermarkImgElement = null;

// Offscreen (full-res) canvas for export
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d', {alpha:true});

// Reusable temporary canvases to avoid churn
const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d', {alpha:true});
const wmCanvas = document.createElement('canvas');
const wmCtx = wmCanvas.getContext('2d', {alpha:true});

// Cache for adaptive watermark results keyed by `${w}x${h}:${mode}`
const adaptiveCache = new Map();

let previewScale = 1;
let colorAdaptAvailable = false;
let selectedColorMode = 'adaptive';

// Helpers
function setHighQuality(ctx){
  if(!ctx) return;
  ctx.imageSmoothingEnabled = true;
  try { ctx.imageSmoothingQuality = 'high'; } catch(e){}
}

// Debounce helper
function debounce(fn, ms=120){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

// Try to detect whether canvas readback is allowed (CORS)
function assessCanvasTaint(){
  // quick test on an ephemeral tiny canvas
  try {
    const c = document.createElement('canvas');
    c.width = 2; c.height = 2;
    const cx = c.getContext('2d');
    cx.fillRect(0,0,2,2);
    cx.getImageData(0,0,1,1);
    colorAdaptAvailable = true;
    adaptFlag.textContent = 'ON';
    adaptFlag.className = 'status-on';
  } catch(e){
    colorAdaptAvailable = false;
    adaptFlag.textContent = 'OFF (CORS)';
    adaptFlag.className = 'status-off';
  }
}

// Create thumbnails (reuse Image objects; revoke URLs)
async function createThumbnails(){
  wmList.innerHTML = '';
  for(const p of watermarkPaths){
    const img = document.createElement('img');
    img.className = 'wm-thumb';
    img.title = p;
    img.dataset.src = p;
    img.onclick = ()=>selectWatermarkUrl(p, img);
    wmList.appendChild(img);

    // fetch but don't block UI; give visual feedback on fail
    fetch(p, {mode:'cors'}).then(res=>{
      if(!res.ok) throw new Error('HTTP ' + res.status);
      return res.blob();
    }).then(blob=>{
      const url = URL.createObjectURL(blob);
      img.src = url;
      // revoke after load to avoid leaks
      img.onload = ()=>{ URL.revokeObjectURL(url); };
      img.onerror = ()=>{ img.style.opacity='0.5'; img.alt='err'; };
    }).catch(e=>{
      console.warn('thumb fetch fail', p, e);
      img.style.opacity='0.5';
      img.alt='err';
    });
  }
}

// Load watermark from URL into bitmap + element
async function loadWatermarkFromUrl(url){
  try{
    const res = await fetch(url, {mode:'cors'});
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const blob = await res.blob();
    // createImageBitmap is faster and suitable for drawImage
    const bitmap = await createImageBitmap(blob, {resizeQuality:'high'});
    watermarkBitmap = bitmap;
    const el = new Image();
    el.onload = ()=>{
      watermarkImgElement = el;
      // Invalidate cache when watermark changes
      adaptiveCache.clear();
      assessCanvasTaint();
      renderPreview();
    };
    el.src = URL.createObjectURL(blob);
    el.onloadend = ()=>{ URL.revokeObjectURL(el.src); };
  }catch(e){
    console.warn('loadWatermarkFromUrl failed', e);
    alert('Не удалось загрузить вотермарку через fetch (возможно CORS). Попробуйте загрузить локально.');
  }
}

async function selectWatermarkUrl(url, thumbEl){
  document.querySelectorAll('.wm-thumb').forEach(t=>t.classList.remove('selected'));
  if(thumbEl) thumbEl.classList.add('selected');
  await loadWatermarkFromUrl(url);
}

// Local upload for watermark (keeps same flow but from file)
wmUpload.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const blob = f;
  try{
    const bitmap = await createImageBitmap(blob, {resizeQuality:'high'});
    watermarkBitmap = bitmap;
    const el = new Image();
    el.onload = ()=>{
      watermarkImgElement = el;
      adaptiveCache.clear();
      assessCanvasTaint();
      renderPreview();
      // add thumbnail (reuse objectURL)
      const thumb = document.createElement('img');
      thumb.className = 'wm-thumb selected';
      thumb.src = URL.createObjectURL(blob);
      thumb.style.width='60px'; thumb.style.height='40px'; thumb.style.objectFit='contain';
      document.querySelectorAll('.wm-thumb').forEach(t=>t.classList.remove('selected'));
      thumb.classList.add('selected');
      wmList.appendChild(thumb);
      // revoke later to avoid memory leak
      thumb.onload = ()=> URL.revokeObjectURL(thumb.src);
    };
    el.src = URL.createObjectURL(blob);
  }catch(err){
    console.error('wmUpload error', err);
    alert('Ошибка загрузки водяного знака. Убедитесь, что файл является корректным изображением.');
  }
});

// Source image load
fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  if(!f.type.startsWith('image/')){ alert('Пожалуйста, загрузите изображение.'); return; }
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    srcImage = img;
    srcWidth = img.naturalWidth;
    srcHeight = img.naturalHeight;
    offscreenCanvas.width = srcWidth; offscreenCanvas.height = srcHeight;
    adaptiveCache.clear(); // invalidate cache when source changes
    fitPreviewCanvas(); // sets previewScale and previewCanvas size
    // slight delay to let layout settle before taint test
    setTimeout(()=>{ assessCanvasTaint(); renderPreview(); }, 30);
    imageInfo.textContent = `Изображение: ${srcWidth}x${srcHeight}, ${(f.size/(1024*1024)).toFixed(1)} МБ`;
    imageInfoShort.textContent = f.name;
    URL.revokeObjectURL(url);
  };
  img.onerror = (ev)=>{ alert('Не удалось загрузить изображение'); console.error(ev); URL.revokeObjectURL(url); };
  img.src = url;
});

// compute watermark size to cover full height (same logic as before)
function computeWatermarkFitFull(){
  if(!srcWidth || !srcHeight) return null;
  if(!watermarkBitmap && !watermarkImgElement) return null;
  const wmW = watermarkBitmap ? watermarkBitmap.width : watermarkImgElement.naturalWidth;
  const wmH = watermarkBitmap ? watermarkBitmap.height : watermarkImgElement.naturalHeight;
  const scaleFactor = srcHeight / wmH;
  const w = Math.round(wmW * scaleFactor);
  const h = Math.round(wmH * scaleFactor);
  return {w,h};
}

// Create adaptive watermark for given background context at integer coordinates.
// Uses caching by (w,h,mode,sourceHash) to avoid repeated pixel loops.
// IMPORTANT: this function expects backgroundCtx to be the same coordinate space as intended (fullres or preview)
function createAdaptiveWatermark(backgroundCtx, wmX, wmY, wmWidth, wmHeight, mode='adaptive'){
  if(!colorAdaptAvailable) return null;
  // clamp ints
  const bx = Math.max(0, Math.round(wmX));
  const by = Math.max(0, Math.round(wmY));
  let bw = Math.max(1, Math.round(wmWidth));
  let bh = Math.max(1, Math.round(wmHeight));
  const bCanvas = backgroundCtx.canvas;
  if(bx + bw > bCanvas.width) bw = Math.max(1, bCanvas.width - bx);
  if(by + bh > bCanvas.height) bh = Math.max(1, bCanvas.height - by);
  if(bw <= 0 || bh <= 0) return null;

  const cacheKey = `${bw}x${bh}:${mode}`;
  if(adaptiveCache.has(cacheKey)){
    return adaptiveCache.get(cacheKey);
  }

  // prepare wmCanvas and draw scaled watermark once
  wmCanvas.width = bw;
  wmCanvas.height = bh;
  setHighQuality(wmCtx);
  wmCtx.clearRect(0,0,bw,bh);
  if(watermarkBitmap){
    wmCtx.drawImage(watermarkBitmap, 0, 0, watermarkBitmap.width, watermarkBitmap.height, 0, 0, bw, bh);
  } else if (watermarkImgElement){
    wmCtx.drawImage(watermarkImgElement, 0, 0, watermarkImgElement.naturalWidth, watermarkImgElement.naturalHeight, 0, 0, bw, bh);
  }

  // When reading background pixels many times, hint the browser
  try{ backgroundCtx.canvas.getContext('2d', {willReadFrequently:true}); } catch(e){ /* ignore */ }

  // read pixel data
  let wmData, bgData;
  try {
    wmData = wmCtx.getImageData(0,0,bw,bh);
    bgData = backgroundCtx.getImageData(bx, by, bw, bh);
  } catch(e) {
    console.warn('createAdaptiveWatermark: pixel read failed', e);
    return null;
  }

  // create output image data
  const out = tempCtx.createImageData(bw,bh);
  const wdata = wmData.data, bdata = bgData.data, odata = out.data;
  // brightness threshold - could be tuned
  for(let i=0;i<wdata.length;i+=4){
    const alpha = wdata[i+3];
    if(alpha < 10){
      odata[i+3] = 0;
      continue;
    }
    const br = 0.299*bdata[i] + 0.587*bdata[i+1] + 0.114*bdata[i+2];
    const value = br > 128 ? 0 : 255;
    odata[i] = value; odata[i+1] = value; odata[i+2] = value; odata[i+3] = alpha;
  }

  // draw to a canvas (we'll reuse tempCanvas as holder but clone the bitmap to a new offscreen canvas object)
  tempCanvas.width = bw; tempCanvas.height = bh;
  tempCtx.putImageData(out, 0, 0);
  // create an ImageBitmap to reduce memory and allow fast drawImage later
  const resultBitmapPromise = createImageBitmap(tempCanvas);

  // store promise in cache so concurrent requests reuse it
  adaptiveCache.set(cacheKey, resultBitmapPromise);

  return resultBitmapPromise; // returns a Promise<ImageBitmap>
}

// Draw watermark into a context with high quality, supports tiling when watermark source smaller
function drawWatermarkHighQuality(ctx, centerX, centerY, targetW, targetH){
  setHighQuality(ctx);
  if(!watermarkBitmap && watermarkImgElement){
    ctx.drawImage(watermarkImgElement, centerX - targetW/2, centerY - targetH/2, targetW, targetH);
    return;
  }
  const srcW = watermarkBitmap.width, srcH = watermarkBitmap.height;

  // If source is very narrow relative to target height — tile horizontally
  if(srcW < targetW * 0.55){
    // draw tiled watermark into tempCanvas then draw scaled
    tempCanvas.width = Math.max(1, Math.round(targetW));
    tempCanvas.height = Math.max(1, Math.round(targetH));
    const tctx = tempCtx;
    tctx.clearRect(0,0,tempCanvas.width,tempCanvas.height);
    setHighQuality(tctx);
    const stampW = Math.round(srcW * (targetH / srcH));
    const stampH = Math.round(targetH);
    let x = 0;
    while(x < tempCanvas.width){
      tctx.drawImage(watermarkBitmap, 0, 0, srcW, srcH, x, 0, stampW, stampH);
      x += stampW;
    }
    ctx.drawImage(tempCanvas, centerX - targetW/2, centerY - targetH/2, targetW, targetH);
    return;
  }

  // default: draw scaled normally
  ctx.drawImage(watermarkBitmap, 0, 0, srcW, srcH, Math.round(centerX - targetW/2), Math.round(centerY - targetH/2), Math.round(targetW), Math.round(targetH));
}

// MAIN preview render (renders previewCanvas)
async function renderPreview(){
  if(!previewCtx) return;
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  if(srcImage && srcImage.complete){
    try{ previewCtx.drawImage(srcImage, 0, 0, Math.round(srcWidth * previewScale), Math.round(srcHeight * previewScale)); } catch(e){ console.warn('Ошибка рисования изображения:', e); }
  }

  if((watermarkBitmap || watermarkImgElement) && srcWidth && srcHeight){
    const fit = computeWatermarkFitFull();
    if(fit){
      const displayW = Math.max(1, Math.round(fit.w * previewScale));
      const displayH = Math.max(1, Math.round(fit.h * previewScale));
      const centerX = previewCanvas.width / 2;
      const centerY = previewCanvas.height / 2;
      const x = Math.round(centerX - displayW/2);
      const y = Math.round(centerY - displayH/2);

      let wmToDraw = null;

      if(selectedColorMode === 'adaptive' && colorAdaptAvailable){
        // createAdaptiveWatermark returns a Promise<ImageBitmap>
        try{
          const maybePromise = createAdaptiveWatermark(previewCtx, x, y, displayW, displayH, 'adaptive');
          if(maybePromise){
            const bitmap = await maybePromise; // cached promises are returned if available
            if(bitmap) previewCtx.drawImage(bitmap, x, y, displayW, displayH);
            else drawWatermarkHighQuality(previewCtx, centerX, centerY, displayW, displayH);
          } else {
            drawWatermarkHighQuality(previewCtx, centerX, centerY, displayW, displayH);
          }
        }catch(e){ console.warn('Ошибка создания адаптивного водяного знака:', e); drawWatermarkHighQuality(previewCtx, centerX, centerY, displayW, displayH); }
      } else if(colorAdaptAvailable && selectedColorMode !== 'adaptive'){
        // recolor: draw into tempCanvas once and tint pixels
        try{
          tempCanvas.width = displayW; tempCanvas.height = displayH;
          const tctx = tempCtx;
          tctx.clearRect(0,0,displayW,displayH);
          drawWatermarkHighQuality(tctx, displayW/2, displayH/2, displayW, displayH);
          const imageData = tctx.getImageData(0,0,displayW,displayH);
          const data = imageData.data;
          const targetValue = selectedColorMode === 'light' ? 255 : 0;
          for(let i=0;i<data.length;i+=4){
            if(data[i+3] > 10){
              data[i] = targetValue; data[i+1] = targetValue; data[i+2] = targetValue;
            }
          }
          tctx.putImageData(imageData,0,0);
          previewCtx.drawImage(tempCanvas, x, y, displayW, displayH);
        }catch(e){
          console.warn('Ошибка перекрашивания:', e);
          drawWatermarkHighQuality(previewCtx, centerX, centerY, displayW, displayH);
        }
      } else {
        drawWatermarkHighQuality(previewCtx, centerX, centerY, displayW, displayH);
      }
    }
  }

  const modeInfo = selectedColorMode === 'adaptive' ? 'adaptive' : selectedColorMode;
  posInfo.textContent = `preview: adapt=${colorAdaptAvailable ? 'YES':'NO'} mode=${modeInfo} wm=${watermarkBitmap || watermarkImgElement ? 'loaded' : 'none'}`;
}

// compositeOffscreen: compose at full resolution for export
async function compositeOffscreen(){
  if(!srcWidth || !srcHeight) throw new Error('No source loaded');
  offscreenCtx.clearRect(0,0,offscreenCanvas.width,offscreenCanvas.height);
  setHighQuality(offscreenCtx);
  if(srcImage) offscreenCtx.drawImage(srcImage, 0, 0, srcWidth, srcHeight);

  if(watermarkBitmap || watermarkImgElement){
    const fit = computeWatermarkFitFull();
    if(!fit) return;
    const w = fit.w, h = fit.h;
    const centerX = Math.round(srcWidth/2);
    const centerY = Math.round(srcHeight/2);
    const x = Math.round(centerX - w/2);
    const y = Math.round(centerY - h/2);

    if(selectedColorMode === 'adaptive' && colorAdaptAvailable){
      try{
        const maybePromise = createAdaptiveWatermark(offscreenCtx, x, y, w, h, 'adaptive');
        if(maybePromise){
          const bitmap = await maybePromise;
          if(bitmap) offscreenCtx.drawImage(bitmap, x, y, w, h);
          else drawWatermarkHighQuality(offscreenCtx, centerX, centerY, w, h);
        } else drawWatermarkHighQuality(offscreenCtx, centerX, centerY, w, h);
      }catch(e){ console.warn('Ошибка создания адаптивного водяного знака при экспорте:', e); drawWatermarkHighQuality(offscreenCtx, centerX, centerY, w, h); }
    } else if(colorAdaptAvailable){
      try{
        tempCanvas.width = w; tempCanvas.height = h;
        const tctx = tempCtx;
        setHighQuality(tctx); tctx.clearRect(0,0,w,h);
        drawWatermarkHighQuality(tctx, w/2, h/2, w, h);
        const imageData = tctx.getImageData(0,0,w,h);
        const data = imageData.data;
        const targetValue = selectedColorMode === 'light' ? 255 : 0;
        for(let i=0;i<data.length;i+=4){
          if(data[i+3] > 10) { data[i]=targetValue; data[i+1]=targetValue; data[i+2]=targetValue; }
        }
        tctx.putImageData(imageData,0,0);
        offscreenCtx.drawImage(tempCanvas, x, y, w, h);
      }catch(e){ console.warn('Ошибка перекрашивания при экспорте:', e); drawWatermarkHighQuality(offscreenCtx, centerX, centerY, w, h); }
    } else {
      drawWatermarkHighQuality(offscreenCtx, centerX, centerY, w, h);
    }
  }
}

// Exports
exportPng.addEventListener('click', async ()=>{
  try{
    await compositeOffscreen();
    offscreenCanvas.toBlob(blob=>{
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'out.png';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
    }, 'image/png');
  }catch(e){ alert('Export fail: '+e.message); console.error(e); }
});

exportJpg.addEventListener('click', async ()=>{
  try{
    await compositeOffscreen();
    offscreenCanvas.toBlob(blob=>{
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'out.jpg';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
    }, 'image/jpeg', 0.95);
  }catch(e){ alert('Export fail: '+e.message); console.error(e); }
});

resetBtn.addEventListener('click', ()=>{
  srcImage = null; watermarkBitmap = null; watermarkImgElement = null;
  srcWidth=0; srcHeight=0; offscreenCanvas.width = offscreenCanvas.height = 1;
  previewCanvas.width = previewCanvas.height = 1;
  imageInfo.textContent = 'Загрузите изображение чтобы увидеть параметры';
  imageInfoShort.textContent = 'No source';
  posInfo.textContent = '-'; adaptFlag.textContent = 'UNKNOWN';
  adaptiveCache.clear();
  wmList.innerHTML = '';
  createThumbnails();
  renderPreview();
});

// color option handlers
colorOptions.forEach(option => {
  option.addEventListener('click', ()=>{
    colorOptions.forEach(opt=>opt.classList.remove('selected'));
    option.classList.add('selected');
    selectedColorMode = option.dataset.color;
    // changing color invalidates some caches
    adaptiveCache.clear();
    renderPreview();
  });
});

// fit preview canvas to holder and device
function fitPreviewCanvas(){
  const holder = previewHolder;
  const maxW = holder.clientWidth, maxH = 640;
  if(!srcWidth || !srcHeight){
    previewCanvas.width = 800; previewCanvas.height = 450; previewScale = 1; setHighQuality(previewCtx); return;
  }
  const scale = Math.min(maxW/srcWidth, maxH/srcHeight, 1);
  previewScale = scale;
  previewCanvas.width = Math.round(srcWidth * scale);
  previewCanvas.height = Math.round(srcHeight * scale);
  previewCanvas.style.width = previewCanvas.width + 'px';
  previewCanvas.style.height = previewCanvas.height + 'px';
  setHighQuality(previewCtx);
}

// Debounced resize
window.addEventListener('resize', debounce(()=>{
  fitPreviewCanvas();
  renderPreview();
}, 120));

// computeWatermarkFitFull already defined above

// initialisation
window.addEventListener('load', ()=>{
  assessCanvasTaint();
  createThumbnails();
  setHighQuality(previewCtx);
  setHighQuality(offscreenCtx);
  offscreenCanvas.width = offscreenCanvas.height = 1;
  // initial render
  renderPreview();
});
</script>
</body>
</html>
